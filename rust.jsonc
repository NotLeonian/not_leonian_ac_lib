/*
Copyright (c) 2023 Not_Leonian
Released under the MIT license
https://opensource.org/licenses/mit-license.php
*/
{
	"dfs": {
        "prefix": "dfs",
        "body": [
            "let mut seen=vec![false;${1:n}];",
            "seen[${2:0}]=true;",
            "let mut stack=vec![$2];",
            "while let Some(v)=stack.pop() {",
            "    for &(u,w) in &${3:g}[v] {",
            "        if !seen[u] {",
            "            seen[u]=true;",
            "            stack.push(u);",
            "        }",
            "    }",
            "}$0"
        ],
        "description": "帰りがけ順には処理を行わないDFS"
    },
	"dfs_postorder": {
        "prefix": "dfs_postorder",
        "body": [
            "let mut seen=vec![false;${1:n}];",
            "seen[${2:0}]=true;",
            "let mut stack=vec![$2+$1,$2];",
            "while let Some(v)=stack.pop() {",
            "    if v<n {",
            "        for &(u,w) in &${3:g}[v] {",
            "            if !seen[u] {",
            "                seen[u]=true;",
            "                stack.push(u);",
            "            }",
            "        }",
            "    } else {",
            "        let v=v-n;",
            "    }",
            "}$0"
        ],
        "description": "帰りがけ順にも処理を行うDFS"
    },
	"bfs": {
        "prefix": "bfs",
        "body": [
            "let mut seen=vec![false;${1:n}];",
            "seen[${2:0}]=true;",
            "let mut queue=std::collections::VecDeque::<usize>::new();",
            "queue.push_back($2);",
            "while let Some(v)=queue.pop_front() {",
            "    for &(u,w) in &${3:g}[v] {",
            "        if !seen[u] {",
            "            seen[u]=true;",
            "            queue.push_back(u);",
            "        }",
            "    }",
            "}$0"
        ],
        "description": "BFS"
    },
    "modint_fact": {
        "prefix": "modint_fact",
        "body": [
            "let invs=construct_modint_inverses::<${1:ModInt998244353}>(${2:n+1});",
            "let facts=construct_modint_facts::<${1:ModInt998244353}>(${2:n+1});",
            "let factinvs=construct_modint_fact_inverses::<${1:ModInt998244353}>(${2:n+1}, &invs);",
            "let ncr=|n:usize,r:usize| facts[n]*factinvs[r]*factinvs[n-r];"
        ],
        "description": "ModIntによる階乗と階乗の逆元や二項係数の前計算"
    }
}
